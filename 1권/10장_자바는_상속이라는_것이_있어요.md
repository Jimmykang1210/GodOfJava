### 10장 자바는 상속이라는 것이 있어요

- `extends` 클래스를 상속 받음
    - 상속받게 되면 부모 클래스에 선언되어 있는 `public` 및 `protected`로 선언된 모든 변수와  메소드를 가지고 있는 것처럼 사용
    - 다른 패키지에 선언된 부모 클래스의 접근 제어자가 없거나 `private`로 선언된 것들은 자식 클래스로 사용 불가
- `UML`(Unified Modeling Language)
    - 소프트웨어 시스템의 구조와 행동을 시각화하고 문서화하며, 사양을 표현하기 위한 표준 모델링 언어
    - 객체 지향 설계와 비즈니스 프로세스 모델링에 널리 사용
    - ex) 클래스 다이어그램, 시퀀스 다이어그램, 유스케이스 다이어그램, 액티비티 다이어그램
- 상속
    - 부모 클래스에서는 기본 생성자를 만들어 놓는 것 이외에는 상속을 위해서 아무런 작업을 할 필요 없음
    - 자식 클래스는 클래스 선언시 `extends` 다음에 부모 클래스 이름을 적음
    - 자식 클래스의 생성자가 호출되면, 자동으로 부모 클래스의 매개 변수 없는 생성자(기본 생성자)가 실행
    - 자식 클래스에서는 부모 클래스에 있는 `public`, `protected`로 선언된 모든 인스턴스 및 클래스 변수와 메소드를 사용 가능
    - 부모 클래스가 가지고 있는 변수와 메소드를 상속받음으로써 개발 단축
    - 하나의 클래스를 잘 만들면. 해당 클래스를 상속받아 추가적인 기능을 넣어 사용 가능
    - 다중 상속은 불가능
- 매개 변수가 있는 생성자를 만들었을 경우, 기본 생성자는 자동으로 만들어지지 않음
    - 매개 변수가 없는 기본 생성자를  컴파일 시에 자동 생성
    - 자식 클래스에서 부모 클래스의 생성자를 명시적으로 지정하는 `super()` 사용
    - `super()`를 사용하여 생성자를 호출할 때에는 모호하게 null을 넘기는 것보다는 호출하고자 하는 생성자의 기본 타입을 넘겨주는 것이 좋음
    - 자식 클래스의 생성자에서 `super()`를 명시적으로 지정하지 않으면, 컴파일 시 자동으로 `super()` 추가
- 메소드 Overriding
    - 자식 클래스에서 부모 클래스에 있는 메소드와 동일하게 선언
    - 부모 클래스에 선언되어 있는 메소드와 동일하게 선언되어 있는 메소드를 자식 클래스에 선언하면 자식 클래스의 메소드만 실행
    - 생성자의 경우, 자동으로 부모 클래스에 있는 생성자를 호출하는 `super()`가 추가되지만 메소드는 다름
    - Overriding된, 부모 클래스와 동일한 리턴 타입을 가져야 함
    - Overriding된 메소드의 접근 제어자는 부모 클래스에 있는 메소드와 달라도 되지만, 접근 권한이 확장되는 경우에만 허용
        - 접근 권한이 축소될 경우, 컴파일 에러 발생
        - `public` > `protected` > `package-private` > `private` (오른쪽으로 갈수록 접근 권한이 좁아짐)
        - 부모 클래스에서 `private`로 선언했으면, 자식은 어떤 것으로 선언하든지 상관 없음
- 참조 자료형은 자식 클래스의 타입을 부모 클래스의 타입으로 형 변환하면, 부모 클래스에서 호출할 수 있는 메소드들은 자식 클래스에서도 가능
    - 형 변환을 명시적으로 해줄 필요가 없음
- `instanceof`
    - 클래스(타입) 체크 시에 사용, 리턴 타입은 `boolean`
    - `instanceof` 예약어 사용 시, 객체 타입 확인 가능
    - `instanceof` 타입 확인 시, 부모 타입도 `true`
    - ex) `if (targetObj **instanceof** TargetClass)`
- 참조 자료형도 형 변환이 가능
- 자식 타입의 객체를 부모 타입으로 자동 형 변환 가능
- 부모 타입의 객체를 자식 타입으로 형 변환 시, 명시적으로 타입 지정 필수, 부모 타입의 실제 객체는 자식 타입
- 다형성
    - 형 변환을 하더라도, 실제 호출되는 것은 원래 객체에 있는 메소드가 호출
- 상속 관련 정리
    - 자식 클래스의 생성자가 호출되면 자동으로 부모 클래스의 매개 변수가 없는 기본 생성자가 호출, 명시적으로 `super()` 지정 가능
    - 부모 클래스의 생성자를 명시적으로 호출하려면 `super()` 사용
    - 부모 클래스에 `private`로 선언된 변수를 제외한 모든 변수가 자신의 클래스에 선언된 것처럼 사용 가능
    - 부모 클래스에 선언된 변수와 동일한 이름을 가지는 변수를 선언할 수 있음, 엎어쓰는 것은 권장하지 않음
    - 부모 클래스에 선언되어 있지 않은 이름의 변수를 선언 가능
    - 변수처럼 부모 클래스에 선언된 메소드들이 자신의 클래스에 선언된 것처럼 사용 가능
    - 부모 클래스에 선언된 메소드와 동일한 시그니처를 사용함으로써 메소드를 overriding 가능
    - 부모 클래스에 선언되어 있지 않는 이름의 메소드를 선언 가능
- 정리 문제
    - 상속을 받는 클래스의 선언문에 사용하는 키워드는 무엇인가요?
        - `extends`
    - 상속을 받은 클래스의 생성자를 수행하면 부모의 생성자도 자동으로 수행되나요?
        - 자동으로 수행
    - 부모 클래스의 생성자를 자식 클래스에서 직접 선택하려고 할 때 사용하는 예약어는 무엇인가요?
        - `super()`
    - 메소드 Overriding과 Overloading을 정확하게 설명해 보세요.
        - 메소드 Overriding: 자식 클래스에서 부모 클래스에 있는 메소드와 동일하게 선언 (재선언)
        - 메소드 Overloading: 동일한 클래스 내에서 동일한 이름의 메소드를 여러 번 정의 (매개 변수 확장)
    - A가 부모, B가 자식 클래스라면 `A a = new B();`의 형태로 객체 생성이 가능하가요?
        - 가능
    - 명시적으로 형 변환을 하기 전에 타입을 확인하려면 어떤 예약어를 사용해야 하나요?
        - `instanceof`
    - 6에서 사용한 예약어의 좌측에는 어떤 값이, 우측에는 어떤 값이 들어가나요?
        - 좌측: 확인할 객체, 우측: 클래스(타입)
    - 6의 예약어의 수행 결과는 어떤 타입으로 제공되나요?
        - `boolean`
    - Polymorphism이라는 것은 도대체 뭔가요?
        - 다형성: 형 변환을 하더라도, 실제 호출되는 것은 원래 객체에 있는 메소드가 호출