### 17장 어노테이션이라는 것도 알아야 한다

- 어노테이션
    - 클래스나 메소드 등의 선언시에 `@`를 사용하는 것을 말함, 메타데이터라고도 불림
    - 컴파일러에게 정보를 알려줌
    - 컴파일할 때와 설치 시의 작업을 지정
    - 실행할 때 별도의 처리가 필요할 경우
- 자바 언어에서 사용하기 위해 정해진 어노테이션
    - `@Override`
        - 해당 메소드가 부모 클래스에 있는 메소드를 `Override` 했다는 것을 명시적으로 선언
        - 어노테이션 추가 시에 개발자가 쉽게 확인 가능
        - 제대로 `Override` 했는지 확인하는 수단으로도 사용 가능
    - `@Deprecated`
        - 미리 만들어져 있는 클래스나 메소드가 더 이상 사용되지 않는 경우 선언
        - 하위 호환성을 위해 선언 필요 → 추후 계도 기간을 거쳐 알림을 준 후에 지우는 것이 바람직함
    - `@SupressWarnings`
        - 컴파일러에게 경고를 알리는 경우, 프로그램에는 문제가 없음
        - 어노테이션의 종류에 따라 속성값을 지정하는 것도 존재
    - Meta annotation은 어노테이션을 생성할 때 사용
        - `@Target`
            - 어노테이션을 어떤 것에 적용할지 선언
            - 괄호 안에 적용 대상을 지정
                - `CONSTRUCTOR`: 생성자 선언시
                - `FIELD`: enum 상수를 포함한 필드(field) 값 선언시
                - `LOCAL VARIABLE`: 지역 변수 선언시
                - `METHOD`: 메소드 선언시
                - `PACKAGE`: 패키지 선언시
                - `PARAMETER`: 매개 변수 선언시
                - `TYPE`: 클래스. 인터페이스, enum 등 선언시
        - `@Retention`
            - 얼마나 오래 어노테이션 정보가 유지되는지 선언
            - 괄호 안에 지정하는 적용 가능한 대상
                - `SOURCE`: 어노테이션 정보가 컴파일시 사라짐
                - `CLASS`: 크래스 파일에 있는 어노테이션 정보가 컴파일러에 의해서 참조 가능, JVM에서는 사라짐
                - `RUNTIME`: 실행 시, 어노테이션 정보가 가상 머신에 의해 참조 가능
        - `@Documented`
            - 해당 어노테이션에 대한 정보가 JavaDocs API 문서에 포함
        - `@Inherited`
            - 모든 자식 클래스에서 부모 클래스의 어노테이션을 사용 가능하다는 것을 선언
    - 메소드처럼 어노테이션 안에 선언해 놓으면, 해당 어노테이션을 사용할 때 해당 항목에 대한 타입으로 값을 지정 가능
    - `default` 예약어 사용 시, 뒤에 있는 값이 이 어노테이션을 사용할 때의 기본값
        - 기본 값이 지정되어 있지 않으면 반드시 값을 정해주어야 함
    - 두 개 이상의 어노테이션을 선언할 때에는 중괄호 후에 `,`로 구분
    - 어노테이션을 선언할 때에도 미리 만들어 놓은 어노테이션을 확장하는 것이 불가능, `extends`라는 예약어 사용 불가
    - 어노테이션 용도
        - 제약사항을 선언하기 위해: `@Deprecated, @Override, @Notnull`
        - 용도를 나타내기 위해: `@Entity, @TestCase, @WebService`
        - 행위를 나타내기 위해: `@Statefull, @Transaction`
        - 처리를 나태내기 위해: `@Column, @XmlElement`
    - 어노테이션을 만들어지기 전까지는 모든 자바 애플리케이션의 설정을 `XML`이나 `properties`라는 파일에 지정해 옴
    - 어노테이션이 만들어지면서, 각 설정이 필요한 위치에 관련 설정이 존재하면서 코드 가독성이 좋아짐
    - 어노테이션이 변환된 모습은 컴파일 단계에서 생성되므로, 역컴파일을 하지 않는 이상 확인하기 어려움
- 정리 문제
    - `@Override` 어노테이션의 용도는 무엇인가요?
        - 해당 메소드가 부모 클래스에 있는 메소드를 `Override` 했다는 것을 명시적으로 선언
    - `@SupressWarings` 어노테이션의 용도는 무엇인가요?
        - 더 이상 사용되지 않음을 컴파일러에게 알림
    - `@Deprecated` 어노테이션의 용도는 무엇인가요?
        - 컴파일러에게 경고를 알리는 경우
    - 어노테이션을 선언할 때 사용하는 어노테이션을 무엇이라고 부르나요?
        - 메타 어노테이션
    - 4번의 답에 있는 어노테이션들을 사용할 때 `import` 해야 하는 패키지는 무엇인가요?
        - `java.lang.annotation`
    - `@Target` 어노테이션의 용도는 무엇인가요?
        - 어노테이션을 어떤 것에 적용할지 선언
    - `@Retention` 어노테이션의 용도는 무엇인가요?
        - 얼마나 오래 어노테이션 정보가 유지되는지 선언
    - `@Inherited` 어노테이션의 용도는 무엇인가요?
        - 모든 자식 클래스에서 부모 클래스의 어노테이션을 사용 가능하다는 것을 선언
    - 어노테이션을 선언할 때에는 `class` 대신 어떤 예약어를 사용해야 하나요?
        - `@interface`