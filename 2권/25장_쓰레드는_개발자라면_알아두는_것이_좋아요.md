### 25장 쓰레드는 개발자라면 알아두는 것이 좋아요

- 앞서 일반적으로 만든 클래스와 프로그램은 단일 `Thread`로 동작
- 하나의 JVM이 시작되면 자바 프로세스가 시작 → 프로세스라는 울타리 안에 여러 개의 쓰레드가 동작
- 하나의 프로세스 내에서 여러 쓰레스가 수행 → 여러 프로세스가 공유하는 하나의 쓰레드가 수행되지 않음, 어떤 프로세스든 Thread는 하나 이상 수행
- 아무런 Thread를 생성하지 않아도 JVM을 관리하기 위한 여러 쓰레드가 존재 → ex) GC 관련 Thread
- 프로세스 하나 시작 시 많은 resource가 필요 → 하나의 작업을 동시에 수행하기 위해 여러 개의 프로세스를 띄워서 실행하면 각각 메모리를 할당 필요
    - Thread 하나 추가 시 1MB 내의 메모리를 점유 → Thread를 “경량 프로세스”라고도 부름
- 대부분의 작업은 단일 Thread로 실행하는 것보다는 다중 Thread로 실행하는 것이 더 빠른 시간에 결과를 제공
    - 보다 빠른 처리를 할 필요가 있을 때, Thread를 사용하면 보다 빠른 계산이 가능
- Thread 생성 방법
    - Runnable 인터페이스 사용
        - `run()` 메소드 하나 존재
    - Thread 클래스를 사용
        - Thread 클래스는 Runnable 인터페이스를 구현한 클래스
        - Runnable 인터페이스를 사용하는 것과는 어떤 것을 적용하느냐의 차이 정도 → 큰 차이는 없음
        - 매우 많은 생성자와 메소드를 제공
- Runnable 인터페이스, Thread 클래스 모두 java.lang 패키지에 존재
- Ruunable 인터페이스를 구현하거나 Thread 클래스를 확장 할 때에, run() 메소드를 시작점으로 작성해야 함
    - Thread가 수행되는 우리가 구현하는 메소드는 run() 메소드
    - Thread를 시작하는 메소드는 start()
- Thread 클래스가 다른 클래스를 확장할 필요가 있는 경우에는 Runnable 인터페이스를 구현하면 되고, 그렇지 않은 경우 Thread 클래스 사용하는 것이 편리
    - Thread 클래스를 확장 받아야만 쓰레드로 구현 가능한데, 다중 상속이 불가능 하므로 해당 클래스를 Thread로 만들 수 없음
    - 인터페이스는 여러 개의 인터페이스를 구현해도 문제가 발생하지 않음
- Thread 라는 것을 start() 메소드를 통해 시작한 것은 프로세스가 아닌 하나의 Thread를 JVM에 추가하여 실행
- Thread 구현 시, start() 메소드호출하면, Thread 클래스에 있는 run() 메소드의 내용이 끝나든, 끝나지 않든 Thread를 시작한 메소드에서 그 다음에 코드를 실행
- 새로 생성한 Thread는 run() 메소드가 종료되면 종료 → run() 메소드가 끝나지 않으면 실행한 애플리케이션은 종료되지 않음

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7dad7672-8f4d-49a8-99b9-223c05d71ea1/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/42df6abc-1fa4-42fc-982b-af501b725a29/Untitled.png)

- 아무런 이름을 지정하지 않으면 Thread의 이름은 “Thread-n”으로 표기 n은 쓰레드가 생성된 순서에 따라 증가
- Thread 이름을 지정한다면 해당 Thread는 별도의 이름을 가짐, Thread의 이름이 겹쳐도 예외나 에러가 발생하지 않음
- ThreadGroup
    - Thread 생성 시 Thread를 묶는 기능
    - Thread의 관리를 용이하게 하기 위한 클래스
    - Thread 그룹에 있는 모든 Thread의 객체를 담으려면 activeCount() 메소드를 통해 현재 실행중인 Thread의 개수를 정확히 파악 후, 그 개수만큼의 배열 생성
- 자바 프로세스가 시작되면 실행 데이터 공간이 구성, Thread 생성 시, 별도의 Stack이 할당
- Thread에 있는 static 메소드는 대부분 해당 Thread를 위해 존재하는 것이 아닌, JVM에 있는 Thread를 관리하기 위한 용도로 사용
- `Thread.sleep()` 메소드 사용 시, 항상 try-catch 필요, `sleep()` 메소드는 InterruptedException을 던질 수 있음
- Thread 우선 순위: 대기하고 있는 상황에서 더 먼저 수행할 수 있는 순위
    - 대부분 이 값은 기본값으로 사용하는 것을 권장 → 잘못될 경우, 장애 발생 가능성 있음
    - 우선 순위를 정할 일이 있다면 숫자로 정하는 것 보다는 상수를 이용하는 것이 좋음 → 되도록이면 지정하지 않은 것이 좋음
- 데몬 Thread
    - Thread가 수행하기 전에 데몬 여부를 지정해야만 그 Thread가 데몬 Thread로 인식
    - 데몬 Thread가 아닌 사용자 Thread는 JVM이 해당 Thread가 끝날 때까지 기다림
    - 어떤 Thread를 데몬으로 지정하면, 그 Thread가 수행되고 있든, 수행되지 않고 있든 상관 없이 JVM이 끝날 수 있음
    - 해당 Thread가 시작하기(`start()` 메소드 호출되기) 전에 데몬 Thread로 지정되어야만 함 → Thread가 시작한 이후에는 데몬으로 지정 불가
    - 데몬 Thread는 해당 Thread가 종료되지 않아도 다른 실행중인 일반 Thread가 없다면 멈춤
    - 사용 이유: 부가적인 작업을 수행하는 Thread를 선언할 때 데몬 Thread 사용
- Thread와 synchronized는 뗄레야 뗄수 없는 관계
    - 어떤 클래스나 메소드가 Thread에 안전하려면 synchronied를 사용해야만 함
    - 여러 쓰레드가 한 객체에 선언된 메소드에 접근하여 데이터를 처리하려고 할 때 동시에 연산을 수행하여 값이 꼬이는 경우가 발생 가능
        - 한 객체는 하나의 클래스에서 생성된 여러 개의 객체가 아니라 동일한 하나의 객체
        - 메소드에서 인스턴스 변수를 수정하려고 할때만 문제가 발생
    - 매개 변수나 메소드에서만 사용하는 지역변수만 다루는 메소드는 전혀 synchronized 선언 필요 없음
- `join()`: 쓰레드가 종료될때까지 기다림
- synchronized  사용 방법
    - 메소드 자체를 synchronized로 선언하는 방법
    - 메소드 내의 특정 문장만 synchronized로 감싸는 방법
    - `synchronized` 는 여러 쓰레드에서 하나의 객체에 있는 인스턴스 변수를 동시에 처리할 때 발생할 수 있는 문제를 해결하기 위해 필요
    - 다른 Thread에서 작업하고 있다고 하더라도, 새로운 Thread에서 동일한 작업을 같이 처리 → 데이터가 꼬일 수 있음
    - `synchronized(this){…}` 이후에 있는 중괄호 내에 있는 연산만 동시에 여러 쓰레드에서 처리하지 않도록 선언 가능
    - `synchronized` 사용 시에는 하나의 객체를 사용하여 블록  내에 문장을 하나의 Thread만 수행하도록 할 수 있음
    - 변수가 여러개인 경우 여러 개의 객체를 사용하여 `synchronized(object..)` 처리 하는 것이 보다 효율적임
    - 인스턴스 변수가 선언되어 있다 하더라도, 변수가 선언되어 있는 객체를 다른 쓰레드에서 공유할 일이 전혀 없는 경우 `synchronized` 사용할 이유가 없음
    - StringBuffer는 `synchronized` 블록으로 주요 데이터 처리 부분을 감싸 두었고, StringBuilder는 `synchronized` 미사용
        - StringBuffer는 하나의 문자열 객체를 여러 쓰레드에서 공유해야 하는 경우에만 사용
        - StringBuilder는 여러 쓰레드에서 공유할 일이 없는 경우 사용

- 쓰레드의 상태
    - `NEW → 상태 → Terminated`의 라이프 사이클을 가짐
    - `NEW`: 쓰레드 객체는 생성되었지만, 아직 시작하지 않음
    - `RUNNABLE`: 쓰레드가 실행 중인 상태
    - `BLOCKED`: 쓰레드가 실행 중지 상태, 모니터 락이 풀리길 기다림
    - `WAITING`: 쓰레드가 대기중인 상태
    - `TIMED_WAITING`: 특정 시간만큼 쓰레드가 대기중인 상태
    - `TERMINATED`: 쓰레드가 종료된 상태
- `interrupt()` 메소드는 현재 수행중인 쓰레드를 중단
    - InterruptedException을 발생시키며 중단
    - 쓰레드가 시작하기 전이나, 종료된 상태에서 `interrupt()` 메소드 실행 시 에러 없이 진행
    - interrupt() 메소드를 사용해서 Thread를 멈추어야 함
    - isInterrupted() 메소드는 다른 Thread에서 확인 시 사용
    - interrupt() 메소드는 본인의 Thread를 확인할 때 사용

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8eb2370-cd85-4c5c-a60b-a4b1836830d6/Untitled.png)

- 정리 문제
    - Thread와 프로세스의 차이를 이야기해 보세요
        - 프로세스는 운영체제로부터 자원을 할당받는 작업의 단위
        - Thread는 프로세스가 할당받은 자원을 이용하는 실행의 단위
    - 여러분들이 쓰레드 클래스를 만들기 위해서는 어떤 인터페이스를 구현하면 될까요?
        - `Runnable`
    - 2에서 이야기한 인터페이스에 선언되어 있는 유일한 메소드는 무엇인가요?
        - `run()`
    - 쓰레드 클래스를 만들기 위해서 어떤 클래스를 확장하면 되나요?
        - `Thread`
    - 쓰레드가 시작되는 메소드의 이름은 무엇인가요?
        - `run()`
    - 쓰레드를 시작하는 메소드의 이름은 무엇인가요?
        - `start()`
    - 쓰레드에 선언되어 있는 sleep() 메소드의 역할은 무엇인가요?
        - 특정 시간동안 Thread가 정지
    - sleep() 메소드를 사용할 때에는 try-catch로 감싸 주어 예외를 처리해 주어야 하는데, 그 이유는 무엇인가요?
        - InterruptedException을 던질 수 있음
    - 데몬(Daemon) 쓰레드와 일반 쓰레드의 차이는 무엇인가요?
        - 데몬 Thread는 자기 자신의 Thread가 종료 시 종료
        - 일반 Thread는 자기 자신의 Thread가 종료되어도 다른 실행 중인 일반 Thread가 있는 경우 대기
    - synchronized 구문은 왜 써주며, 어디에 사용해야 하나요?
        - 동시에 여러 Thread에서 하나의 값에 접근하려고 할 때 데이터의 정합성을 지키기 위해서 사용
    - synchronized를 사용하는 두 가지 방법은 어떤 것인가요?
        - 메소드 자체를 synchronized로 선언하는 방법
        - 메소드 내의 특정 문장만 synchronized로 감싸는 방법
    - 쓰레드의 상태에는 어떤 것들이 있나요?
        - `NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED`
    - 쓰레드에 선언되어 있는 join() 메소드의 용도는 무엇인가요?
        - 해당 Thread가 종료될 때까지 대기
    - 쓰레드에 선언되어 있는 interrupt() 메소드의 용도는 무엇인가요?
        - 해당 Thread를 종료
    - interrupt() 메소드를 호출하면 해당 쓰레드는 어떤 상태에 있을 때 interrupt() 메소드가 호출된 효과가 발생되나요?
        - sleep(), join(), wait() 메소드가 호출되어 대기중인 상태에만 interrupt() 메소드가 처리
    - object 클래스에 선언된 wait() 메소드의 용도는 무엇인가요?
        - 다른 Thread가 Object 객체에 대한 notify() 메소드나 notifyAll() 메소드를 호출할 때까지 현재 Thread가 대기
    - obiect 클래스에 선언된 notifv() 메소드의 용도는 무엇인가요?
        - `wait()` 메소드로 대기중인 쓰레드가 계속해서 작업을 하도록 깨우는 작업
    - ThreadGroup 클래스에 선언된 enumerate() 메소드의 용도는 무엇인가요?
        - 해당 Thread 그룹에 포함된 Thread나 Thread 그룹의 목록을 매개변수로 넘어온 배열에 담음